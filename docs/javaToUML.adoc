==== Java to UML Parser

Dieses Kapitel beschreibt mögliche Ansätze um aus .java FIles UML darzustellen.

*JavaParser*

Javaparser API kann .java Files parsen und diese in einer
baumartiger Struktur speichern. Dabei können alle nötigen Informationen
herausgefunden werden, welche für die Erstellung eines UMLs relevant sind.
Das Javaparser Projekt ist relativ gut dokumentiert und wird beispielsweise
von IntelliJ verwendet (vgl. <<JavaParser>>: 2019).
Eine erste Variante der InheritorGallery wurde mit JavaParser umgesetzt.
Später wurde jedoch die Generierung des UMLs mithilfe von Reflection erstellt.
Dazu unter mehr.

*JavaSymbolSolver*

Als Teil des Javaparser kann zudem JavaSymbolSolver verwendet werden.
Dieser kann Herkunft der Methodenaufrufe und Variablendeklarationen bestimmen.
Dieses Projekt ist allerdings noch eher neu und wenig verbreitet und dokumentiert.
Auch die Verwendung der JavaSymbolSolver API ist eher umständlich
(vgl. <<Smith>>, Nicholas et al. (2019): 53)

*Reflection*

Nebst den statischen Java Code muss für die InheritorGallery der
Zustand des Programms zur Laufzeit überwacht werden. Die mit abstand
verbreitetste Lösung hierfür ist Reflection.

_Reflection is commonly used by programs which require the ability to examine or
modify the runtime behavior of applications running in the Java virtual machine.”_
(<<Reflection>>: 2019)

Auch für die InheritorGallery wurde Reflection verwendet, da es alle benötigten Informationen
für die Darstellung von UML und der Instanzen bereitstellen kann. Reflection liest den
kompilierten Code zur Laufzeit. Dabei sind einige Informationen, die im .java File
vorhanden waren bereits verloren. Dies stellt auch den einzigen Nachteil von Reflection
für dieses Projekt dar. Namentlich kann die Reihenfolge der Definition der Attribute und
Methoden nicht aufrechterhalten werden. Das ist mit JavaParser möglich. Reflection verfügt
jedoch über weitaus mehr Vorteile. Da der Code zur Laufzeit analysiert wird, wird sichergestellt,
dass nur korrekter Code dargestellt wird. Auch die Handhabung von Reflection ist r
elativ einfach und sehr gut dokumentiert. So kann man etwa die Zusammenstellung
einer Instanz aus den jeweiligen Klassen mit Methoden wie getSuperclass() oder
getInterfaces() einfach und natürlich traversieren. Weiter ist es mit Reflection
möglich die Werte der Attribute herauszulesen oder die Herkunft einer Methode bei
Vererbung ausfindig zu machen.

Beim Implementieren von Reflection zum Lesen von benötigten Informationen zur
Laufzeit wurde festgestellt, dass dabei auch alle Informationen benötigt wurden,
die zur Erstellung des UMLs nötig sind. Folglich wurde auf JavaParser verzichtet,
um den Aufbau der InheritorGallery möglichst einfach und konsistent zu belassen.

*Teilweise vorgefertigte Lösungen*

Hier sollen kurz einige weitere in Betracht gezogene Varianten aufgelistet werden,

die die Erstellung von UML aus .java Files möglich machen.
Der UML-Parser von Github User Shubham Vadhera
(vgl. <<uml-parser-a>>: 2018) benutzt JavaParser für das Einlesen der Files und Yuml
(vgl. <<Yuml>>: 2019) für die Erstellung der Grafiken.
Ähnlich gehen auch Rishiraj Randive
(vgl. <<uml-parser-b>>: 2017)
und Pratik Sanglikar (vgl. <<Java-Parser-UML-Generator>>: 2016) vor.
Diese Lösungen sind für die InheritorGallery eher ungeeignet, da sie zu
unflexibel zu wenig mächtig sind.